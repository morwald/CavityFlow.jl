var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API of Functions","title":"API","text":"","category":"section"},{"location":"api/","page":"API of Functions","title":"API of Functions","text":"Modules = [FourSidedCavityFlow]","category":"page"},{"location":"api/#FourSidedCavityFlow.diff_chebyshev-Tuple{Int64}","page":"API of Functions","title":"FourSidedCavityFlow.diff_chebyshev","text":"diff_chebyshev(n)\n\nCompute the Chebyshev differentiation matrix with n+1 points in the [1, -1]. Returns a vector of nodes and the matrices for the first, second and fourth derivatives.\n\n\n\n\n\n","category":"method"},{"location":"#FourSidedCavityFlow.jl-Documentation","page":"Home","title":"FourSidedCavityFlow.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FourSidedCavityFlow","category":"page"},{"location":"","page":"Home","title":"Home","text":"The four-sided cavity flow is a two-dimensional flow problem. It is an extension of the simple one-sided lid-driven case, where all lids move with the same velocity profile and parallel lids move in opposite directions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<center><img src=\"./assets/foursidedcavity.png\"></center>","category":"page"},{"location":"","page":"Home","title":"Home","text":"partial_t Delta Psi = frac1mathrmRe Delta^2 Psi\n  + (partial_x Psi) partial_y(Delta Psi)\n  - (partial_y Psi) partial_x(Delta Psi)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This Julia module explores a regularized version of the four-sided lid-driven cavity for incompressible fluids to be used as a validator benchmark for Navier-Stokes solvers. The regularization overcomes the corner singularities which are due to the discontinuous boundary conditions. The considered method recovers exponential convergence with a pseudo-spectral Chebyshev discretization scheme. Below the regularization function is shown.  ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This module is not a registered package. To install the FourSidedCavityFlow.jl,  run the following commands in your shell.","category":"page"},{"location":"","page":"Home","title":"Home","text":"git clone https://github.com/morwald/FourSidedCavityFlow.jl.git\ncd FourSidedCavityFlow.jl\njulia","category":"page"},{"location":"","page":"Home","title":"Home","text":"Inside the Julia REPL open the built-in package manager Pkg by pressing ] and then run.","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg>activate .\npkg>instantiate","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will activate the package and download the necessary dependencies.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To set up the four-sided cavity flow problem in Julia, instantiate the struct p, of type CavityStruct, with a Chebyshev polynomial of order n and a Reynolds number mathrmRe. This generates a grid of size (n+1)times(n+1), and all the parameters and cache variables needed to run the simulations. To illustrate, n = 32 is used, which is too small for accurate computations but enough to show how the module works.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using FourSidedCavityFlow \nconst CF = FourSidedCavityFlow\n\nn = 32;\nRe = 1;\np = CF.setup_struct(n, Re);","category":"page"},{"location":"tutorial/#Steady-State-Solutions","page":"Tutorial","title":"Steady-State Solutions","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can run the steadystate function for a given Reynolds number mathrmRe to converge to a steady-state solution with Newton's method. For example the symmetric base solution for a Reynolds of mathrmRe = 50 can be computed by setting the streamfunction matrix to zeros as an initial guess.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"p.params.Re = 50;\nΨ0 = zeros((n + 1), (n + 1));\n\nΨ, iter, tol = CF.steadystate(Ψ0, p);","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The results can be visualized in the physical domain by transposing the Psi matrix and mirror the solution at the y axis. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots\n\ncontourf(reverse(p.params.nodes), reverse(p.params.nodes), Ψ', xlim = (-1, 1), \n    ylim = (-1, 1), aspect_ratio = 1, axis = ([], false), color = :davos)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/#Time-Stepping","page":"Tutorial","title":"Time-Stepping","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The asymmetric solutions can be computed by doing time integration.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"p.params.Re = 100;\ntimesteps = 140;\nh = 1;\nΨi = -1e-3 * abs.(randn((n + 1), (n + 1)));\n\nsol, timeseries = CF.timestepping(Ψi, p, h, timesteps, savesteps = true, verbose = true);\n\ncontourf(reverse(p.params.nodes), reverse(p.params.nodes), sol[end, :, :]'; xlim = (-1, 1), \n   ylim = (-1, 1), aspect_ratio = 1, axis = ([], false), color = :davos)\n\nplot(timeseries, sol[:, p.params.ic, p.params.ic]; xlabel = \"time\", ylabel = \"Ψcenter\", label = false)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorial/#Pseudo-Arclength-Continuation","page":"Tutorial","title":"Pseudo-Arclength Continuation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can continue the asymmetric solution branch as a function of the Reynolds number. The obtained solution of the time-stepping above will be converged with the steady-state function. Then the continuation algorithm is started from this Reynolds number. Here a Delta mathrmRe = 1 is chosen.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Re_start = 100;\np.params.Re = Re_start;\nΨs, iter, tol = CF.steadystate(sol[end, :, :], p);\n\nΔRe = 1;\nRe_steps = 200; # as a test\n#Re_steps = 840; # steps needed to capture the complete curve\n\nfoldercont = \"cont\";\nmkdir(foldercont);\nsol_cont, Re_series = CF.continuation_arclength(foldercont, Ψs, p, Re_start, ΔRe, Re_steps);","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The streamfunction at the different Reynolds steps of the continuation is saved in the predefined folder foldercont (as binaries, JLD2 format) and as well returned from the function call. A CSV file called results.csv contains a summary of the computed steps. The summary can be visualized as follows:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using CSV\nusing DataFrames\n\ndf = CSV.read(\"$foldercont/results.csv\", DataFrame)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let us plot the center value of the streamfunction as a function of the Reynolds number in a bifurcation diagram.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot(df.Re, df.psi_c; xlabel = \"Re\", ylabel = \"Ψcenter\", label = false)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The same can be achieved by using the results stored as binaries or returned from the function call.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using JLD2\nusing FileIO\n\nsol_cont, Re_series = load(\"$foldercont/psis.jld2\", \"sol\", \"Re_series\");\n\nplot(Re_series, sol_cont[:, p.params.ic, p.params.ic]; xlabel = \"Re\", ylabel = \"Ψcenter\", label = false)","category":"page"},{"location":"tutorial/#Linear-Stability-Analysis","page":"Tutorial","title":"Linear Stability Analysis","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A linear stability analysis can be performed within the continuation algorithm by setting the keyword argument lsa = true. Let us compute eigenvalue crossings around the Hopf bifurcation. The already computed asymmetric solutions can be used from the continuation algorithm before.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Re_start = 347;\np.params.Re = Re_start;\n\ndf_upper = filter(row -> row.psi_c > 0.16 || row.psi_c < -0.16 , df);\nidx = argmin(abs.(df_upper.Re .- Re_start));\nrow = df_upper[idx, :];\n\nΨ0 = sol_cont[row.step + 1, :, :] \nΨs, iter, tol = CF.steadystate(Ψ0, p);\n\nΔRe = 0.5;\nRe_steps = 5;\nfolderlsa = \"lsa_hopf\";\nmkdir(folderlsa);\nsol_lsa, lambdas, Re_series = CF.continuation_arclength(folderlsa, Ψs, p, Re_start, ΔRe,\n                                Re_steps, lsa = true);","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now, as an example, the two largest eigenvalues, corresponding to complex conjugate pair of the Hopf bifurcation, can be plotted by using the generated CSV file of the linear stability analysis.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"df_lsa = CSV.read(\"$folderlsa/results.csv\", DataFrame)\n\nplot(df_lsa.Re, df_lsa.lambda1re; xlabel = \"Re\", ylabel = \"Real(λ)\", marker = :x, \n    label = \"λ1\")\nplot!(df_lsa.Re, df_lsa.lambda2re; marker = :+, label = \"λ2\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can see how the real part of the complex conjugate pair of the leading eigenvalues becomes positive at a Reynolds of around 3482. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Another possibility is to use the linearstability function to compute the eigenvalues of already computed states. For example, the crossings of the first pitchfork bifurcation","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Re_series = [65.9, 66.0, 66.1, 66.2, 66.3];\nlambdas = Array{ComplexF64}(undef, (5, (n - 3)*(n - 3)));\n\nΨ0 = zeros((n + 1), (n + 1));\n\nfor (i, Re) in enumerate(Re_series)\n    p.params.Re = Re;\n    Ψ, iter, tol = CF.steadystate(Ψ0, p);\n    u = reshape(Ψ[3:(n - 1), 3:(n - 1)], (n - 3) * (n - 3));\n\n    lambdas[i, :] = CF.linearstability_lambdas(u, p);\nend\n\nplot(Re_series, real(lambdas[:, 1]); xlabel = \"Re\", ylabel = \"Real(λ1)\", marker = :x, \n    label = \"λ1\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The first pitchfork bifurcation is located at around mathrmRe = 662. The bifurcation point can be resolved more precisely by using a 1D newton to find the exact Reynolds number for the pitchfork. But this procedure just works if the Jacobian is well-condition at the bifurcation point.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Re = 66.15;\np.params.Re = Re;\n\nΨ, iter, tol = CF.steadystate(Ψ0, p);\nu = reshape(Ψ[3:(n - 1), 3:(n - 1)], (n - 3) * (n - 3));\n\nRe_p1, u_p1, iter, tol = CF.newton1D_for_linearstability(Re, u, p);\ndisplay(Re_p1)","category":"page"}]
}
